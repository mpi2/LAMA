"""
This module provides the same function as lama.elastix.invert_transforms.py in that it creates Transform parameters
that can be used to propagate labels from atlas to moving image.

The diffrence is in the approach. In this module istead of minimizing the DiplacementmagnitudePenalty using the forawrd
transform as shown in the elastix manual (section 6.1.6), we do a registration of the population avg -> image of iterest
then use the transforms genrated to propagate the labels.


Example structure of output folder generated by this module
-----------------------------------------------------------

.
├── invert.yaml
├── affine
│   └── 1574928_download
│       ├── elastix.log
│       ├── ImageInvertedTransform.txt
│       ├── inversion_parameters.txt
│       ├── IterationInfo.0.R0.txt
│       ├── IterationInfo.0.R1.txt
│       ├── labelInvertedTransform.txt
│       └── TransformParameters.0.txt
├── deformable_128
│   └── 1574928_download
│       ├── elastix.log
│       ├── ImageInvertedTransform.txt
│       ├── inversion_parameters.txt
│       ├── IterationInfo.0.R0.txt
│       ├── labelInvertedTransform.txt
│       └── TransformParameters.0.txt
└── rigid
    └── 1574928_download
        ├── elastix.log
        ├── ImageInvertedTransform.txt
        ├── inversion_parameters.txt
        ├── IterationInfo.0.R0.txt
        ├── IterationInfo.0.R1.txt
        ├── labelInvertedTransform.txt
        └── TransformParameters.0.txt



"""

from pathlib import Path
from os.path import join
from typing import Union, Dict
import os
import shutil

from logzero import logger as logging
import yaml

from lama import common
from lama.registration_pipeline.validate_config import LamaConfig
from lama.registration_pipeline import run_lama
from lama.paths import LamaSpecimenData
from lama.elastix.elastix_registration import move_intemediate_volumes

from lama.elastix import (ELX_TRANSFORM_NAME, ELX_PARAM_PREFIX, LABEL_INVERTED_TRANFORM,
                          IMAGE_INVERTED_TRANSFORM)
from lama.elastix.invert_transforms import (LABEL_REPLACEMENTS, IMAGE_REPLACEMENTS,
                                            )
from lama.elastix.elastix_registration import TargetBasedRegistration


def reverse_registration(config: Union[str, LamaConfig]):
    common.test_installation('elastix')

    if isinstance(config, (Path, str)):
        config = LamaConfig(Path(config))

    # threads = str(config['threads'])

    inv_outdir = config.mkdir('inverted_transforms')

    # Set the fixed volume to be the rigidly-aligned volume from the forward registration
    paths = LamaSpecimenData(config.config_dir).setup()
    fixed_vols_dir = paths.reg_dirs[0]
    # Get the fixed vols
    fixed_vol_paths = common.get_images_ignore_elx_itermediates(fixed_vols_dir)

    # Get the fixed and moving images. They are flipped compared to the forward registration
    moving_vol = config['fixed_volume']

    # Do the forward registration for each image (usually just one image if using the jobrunner script)
    for fixed_vol in fixed_vol_paths:
        run_registration_schedule(config, fixed_vol, moving_vol, inv_outdir)


def run_registration_schedule(config: LamaConfig, fixed_vol, moving_vol: Path, outdir: Path) -> Path:
    """
    Run the registrations specified in the config file, but flip the moving and fixed images

    Returns
    -------
    The path to the final registrered images
    """
    # egp = {'WriteResultImage': 'false',   # We only need the tform files not the images
    #        'WriteResultImageAfterEachResolution': 'true'}

    elastix_stage_parameters = run_lama.generate_elx_parameters(config)

    # Set the moving volume dir and the fixed image for the first stage
    #  Set the fixed volume up for the first stage. This will checnge each stage if doing population average
    stage_ids = []
    stage_spec_dirs = []

    for i, reg_stage in enumerate(config['registration_stage_params']):

        #  Make the stage output dir
        stage_id = reg_stage['stage_id']
        stage_ids.append(stage_id)
        stage_dir = outdir / stage_id
        stage_dir.mkdir(exist_ok=True)

        logging.info("### Reverse registration - current registration step: {} ###".format(stage_id))

        # Make the elastix parameter file for this stage
        elxparam = elastix_stage_parameters[stage_id]
        elxparam_path = join(stage_dir, ELX_PARAM_PREFIX + stage_id + '.txt')

        with open(elxparam_path, 'w') as fh:
            fh.write(elxparam)

        # maybe we should add fixed mask
        fixed_mask = None

        # Do the registrations
        registrator = TargetBasedRegistration(elxparam_path,
                                 moving_vol,
                                 stage_dir,
                                 config['filetype'],
                                 config['threads'],
                                 fixed_mask
                                 )

        registrator.set_target(fixed_vol)

        if reg_stage['elastix_parameters']['Transform'] == 'BSplineTransform':
            if config['fix_folding']:
                logging.info(f'Folding correction for stage {stage_id} set')
                registrator.fix_folding = True

        registrator.run()  # Do the registrations for a single stage
        os.remove(elxparam_path)

        # As the stage output diretory is named as the moving image, but in this case we want it named the same as the
        # fixed image
        stage_spec_dir = next(stage_dir.glob(f'*{moving_vol.stem}'))
        new_stage_spec_dir = stage_dir / fixed_vol.stem
        stage_spec_dir.rename(new_stage_spec_dir)

        stage_spec_dirs.append(new_stage_spec_dir)

        moving_vol = new_stage_spec_dir / moving_vol.name

        src_tform_file = stage_dir / fixed_vol.stem / ELX_TRANSFORM_NAME
        label_tform_file = stage_dir / fixed_vol.stem / LABEL_INVERTED_TRANFORM
        image_tform_file = stage_dir / fixed_vol.stem / IMAGE_INVERTED_TRANSFORM
        modify_elx_parameter_file(src_tform_file, label_tform_file, LABEL_REPLACEMENTS)
        modify_elx_parameter_file(src_tform_file, image_tform_file, IMAGE_REPLACEMENTS)

        # move_intemediate_volumes(stage_dir)

    logging.info("### Reverse registration finished ###")

    # Now delete everything we don't need
    to_keep = [LABEL_INVERTED_TRANFORM, 'elastix.log', IMAGE_INVERTED_TRANSFORM]

    for s in stage_spec_dirs:
        for f in s.iterdir():
            if f.name not in to_keep:
                try:
                    shutil.rmtree(f)
                except NotADirectoryError:
                    f.unlink()

    d = {'inversion_order': stage_ids}
    with open(outdir / 'invert.yaml', 'w') as fh:
        yaml.dump(d, fh)


def modify_elx_parameter_file(elx_param_file: Path, newfile_name: str, replacements: Dict):
    """
    Modifies the elastix input parameter file that was used in the original transformation.
    Turns off writing the image results at the end as we only need an inverted output file.
    Also changes interpolation order in the case of inverting labels

    Parameters
    ----------
    elx_param_file
        path to elastix input parameter file
    newfile_name
        path to save modified parameter file to
    replacements


    """

    try:
        with open(elx_param_file) as old, open(newfile_name, "w") as new:

            for line in old:
                if line.startswith('(WriteResultImage '):
                    line = '(WriteResultImage "false")\n'
                if line.startswith('WriteResultImageAfterEachResolution '):
                   continue
                try:
                    param_name = line.split()[0][1:]
                except IndexError:
                    continue  # comment?

                if param_name in replacements:
                    value = replacements[param_name]
                    try:
                        int(value)
                    except ValueError:
                        # Not an int, neeed quotes
                        line = '({} "{}")\n'.format(param_name, value)
                    else:
                        # An int, no quotes
                        line = '({} {})\n'.format(param_name, value)
                new.write(line)
    except IOError as e:
        logging.error("Error modifying the elastix parameter file: {}".format(e))
        return False
    return True





if __name__ == '__main__':
    import sys
    cfg_path = sys.argv[1]
    reverse_registration(cfg_path)